/**
 * RTMP-E (Encryption)
 * Uses key generated by rtmpdumps from Adobe. Don't sue me please
 * @/// <reference path="https://www.cs.cmu.edu/~dst/Adobe/Gallery/RTMPE.txt" />
 */

import crypto from "crypto";

import HANDSHAKE from "../constant/handshake";
import { logger } from "../config/logger";

// Buffer evaluates to 'f0eec24a8068bee82e00d0d1029e7e576eec5d2d29806fab93b8e636cfeb31ae' in 'hex'
const RandomCrud = Buffer.from([
	0xf0,
	0xee,
	0xc2,
	0x4a,
	0x80,
	0x68,
	0xbe,
	0xe8,
	0x2e,
	0x00,
	0xd0,
	0xd1,
	0x02,
	0x9e,
	0x7e,
	0x57,
	0x6e,
	0xec,
	0x5d,
	0x2d,
	0x29,
	0x80,
	0x6f,
	0xab,
	0x93,
	0xb8,
	0xe6,
	0x36,
	0xcf,
	0xeb,
	0x31,
	0xae
]);

const GenuineFMSConst = "Genuine Adobe Flash Media Server 001";
const GenuineFMSConstCrud = Buffer.concat([Buffer.from(GenuineFMSConst, "utf8"), RandomCrud]);

const GenuineFPConst = "Genuine Adobe Flash Player 001";

const calcHmac = (data: any, key: any): Buffer => {
	const hmac = crypto.createHmac("sha256", key);
	hmac.update(data);

	return hmac.digest();
};

const getClientGenuineConstDigestOffset = (buf: Uint8Array): number => {
	let offset = buf[0] + buf[1] + buf[2] + buf[3];
	offset = (offset % 728) + 12;

	return offset;
};

const getServerGenuineConstDigestOffset = (buf: Uint8Array): number => {
	let offset = buf[0] + buf[1] + buf[2] + buf[3];
	offset = (offset % 728) + 776;

	return offset;
};

const detectClientMessageFormat = (clientsig: Uint8Array): number => {
	const sdl = getServerGenuineConstDigestOffset(clientsig.slice(772, 776));
	let msg = Buffer.concat(
		[clientsig.slice(0, sdl), clientsig.slice(sdl + HANDSHAKE.SHA256DL)],
		1504
	);

	let computedSignature = calcHmac(msg, GenuineFPConst);
	let providedSignature = clientsig.slice(sdl, sdl + HANDSHAKE.SHA256DL);

	if (computedSignature.equals(providedSignature)) return HANDSHAKE.MESSAGE_FORMAT._2;

	const cdl = getClientGenuineConstDigestOffset(clientsig.slice(8, 12));
	msg = Buffer.concat([clientsig.slice(0, cdl), clientsig.slice(cdl + HANDSHAKE.SHA256DL)], 1504);

	computedSignature = calcHmac(msg, GenuineFPConst);
	providedSignature = clientsig.slice(cdl, cdl + HANDSHAKE.SHA256DL);

	if (computedSignature.equals(providedSignature)) return HANDSHAKE.MESSAGE_FORMAT._1;

	return HANDSHAKE.MESSAGE_FORMAT._0;
};

const generateS1 = (messageFormat): Buffer => {
	const randomBytes = crypto.randomBytes(HANDSHAKE.RTMP_SIG_SIZE - 8);
	const handshakeBytes = Buffer.concat(
		[Buffer.from([0, 0, 0, 0, 1, 2, 3, 4]), randomBytes],
		HANDSHAKE.RTMP_SIG_SIZE
	);

	let serverDigestOffset: number;

	if (messageFormat === 1) {
		serverDigestOffset = getClientGenuineConstDigestOffset(handshakeBytes.slice(8, 12));
	} else {
		serverDigestOffset = getServerGenuineConstDigestOffset(handshakeBytes.slice(772, 776));
	}

	const msg = Buffer.concat(
		[
			handshakeBytes.slice(0, serverDigestOffset),
			handshakeBytes.slice(serverDigestOffset + HANDSHAKE.SHA256DL)
		],
		HANDSHAKE.RTMP_SIG_SIZE - HANDSHAKE.SHA256DL
	);
	const hash = calcHmac(msg, GenuineFMSConst);
	hash.copy(handshakeBytes, serverDigestOffset, 0, 32);

	return handshakeBytes;
};

const generateS2 = (messageFormat: number, clientsig: Uint8Array): Buffer => {
	const randomBytes = crypto.randomBytes(HANDSHAKE.RTMP_SIG_SIZE - 32);
	let challengeKeyOffset;

	if (messageFormat === 1) {
		challengeKeyOffset = getClientGenuineConstDigestOffset(clientsig.slice(8, 12));
	} else {
		challengeKeyOffset = getServerGenuineConstDigestOffset(clientsig.slice(772, 776));
	}

	const challengeKey = clientsig.slice(challengeKeyOffset, challengeKeyOffset + 32);
	const hash = calcHmac(challengeKey, GenuineFMSConstCrud);
	const signature = calcHmac(randomBytes, hash);

	const s2Bytes = Buffer.concat([randomBytes, signature], HANDSHAKE.RTMP_SIG_SIZE);

	return s2Bytes;
};

export const generateS0S1S2 = (clientsig: Uint8Array): Buffer => {
	const clientType = clientsig.slice(0, 1);
	const _clientsig = clientsig.slice(1);

	const messageFormat = detectClientMessageFormat(_clientsig);
	let allBytes;

	if (messageFormat === HANDSHAKE.MESSAGE_FORMAT._0) {
		logger.debug("HANDSHAKE: Using simple handshake.");
		allBytes = Buffer.concat([clientType, _clientsig, _clientsig]);
	} else {
		logger.debug("HANDSHAKE: Using complex handshake.");
		allBytes = Buffer.concat([
			clientType,
			generateS1(messageFormat),
			generateS2(messageFormat, _clientsig)
		]);
	}

	return allBytes;
};
