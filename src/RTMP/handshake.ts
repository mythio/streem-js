/**
 * RTMP-E (Encryption)
 * Uses key generated by rtmpdumps from Adobe. Don't sue me please
 * @/// <reference path="https://www.cs.cmu.edu/~dst/Adobe/Gallery/RTMPE.txt" />
 */

import crypto from "crypto";

import HANDSHAKE from "../constant/handshake";

// Buffer evaluates to 'f0eec24a8068bee82e00d0d1029e7e576eec5d2d29806fab93b8e636cfeb31ae' in 'hex'
const RandomCrud = Buffer.from([
	0xf0,
	0xee,
	0xc2,
	0x4a,
	0x80,
	0x68,
	0xbe,
	0xe8,
	0x2e,
	0x00,
	0xd0,
	0xd1,
	0x02,
	0x9e,
	0x7e,
	0x57,
	0x6e,
	0xec,
	0x5d,
	0x2d,
	0x29,
	0x80,
	0x6f,
	0xab,
	0x93,
	0xb8,
	0xe6,
	0x36,
	0xcf,
	0xeb,
	0x31,
	0xae
]);

const GenuineFPConst = "Genuine Adobe Flash Player 001"; //        30B long
const GenuineFMSConst = "Genuine Adobe Flash Media Server 001"; // 36B long
const GenuineFMSConstCrud = Buffer.concat([Buffer.from(GenuineFMSConst, "utf8"), RandomCrud]);

const calcHmac = (data, key): Buffer => {
	const hmac = crypto.createHmac("sha256", key);
	hmac.update(data);
	return hmac.digest();
};

const getClientGenuineFPConstDigestOffset = (buf: Uint8Array): number => {
	let offset = buf[0] + buf[1] + buf[2] + buf[3];
	offset = (offset % 728) + 12;
	return offset;
};

const getServerGenuineFMSConstDigestOffset = (buf: Uint8Array): number => {
	let offset = buf[0] + buf[1] + buf[2] + buf[3];
	offset = (offset % 728) + 776;
	return offset;
};

const detectMessageFormat = (clientSign: Uint8Array): number => {
	const sdl = getServerGenuineFMSConstDigestOffset(clientSign.slice(772, 776));
	let msg = Buffer.concat(
		[clientSign.slice(0, sdl), clientSign.slice(sdl + HANDSHAKE.SHA256DL)],
		1504
	);
	let computedSignature = calcHmac(msg, GenuineFPConst);
	let providedSignature = clientSign.slice(sdl, sdl + HANDSHAKE.SHA256DL);
	if (computedSignature.equals(providedSignature)) return HANDSHAKE.MESSAGE_FORMAT._2;

	const cdl = getClientGenuineFPConstDigestOffset(clientSign.slice(8, 12));
	msg = Buffer.concat([clientSign.slice(0, sdl), clientSign.slice(cdl + HANDSHAKE.SHA256DL)], 1504);
	computedSignature = calcHmac(msg, GenuineFPConst);
	providedSignature = clientSign.slice(sdl, sdl + HANDSHAKE.SHA256DL);
	if (computedSignature.equals(providedSignature)) return HANDSHAKE.MESSAGE_FORMAT._1;

	return HANDSHAKE.MESSAGE_FORMAT._0;
};

const generateS1 = (messageFormat): Buffer => {
	const randomBytes = crypto.randomBytes(HANDSHAKE.RTMP_SIG_SIZE - 8);
	const handshakeBytes = Buffer.concat(
		[Buffer.from([0, 0, 0, 0, 1, 2, 3, 4]), randomBytes],
		HANDSHAKE.RTMP_SIG_SIZE
	);

	let serverDigestOffset;
	if (messageFormat === 1)
		serverDigestOffset = getClientGenuineFPConstDigestOffset(handshakeBytes.slice(8, 12));
	else serverDigestOffset = getServerGenuineFMSConstDigestOffset(handshakeBytes.slice(772, 776));

	const msg = Buffer.concat(
		[
			handshakeBytes.slice(0, serverDigestOffset),
			handshakeBytes.slice(serverDigestOffset + HANDSHAKE.SHA256DL)
		],
		HANDSHAKE.RTMP_SIG_SIZE - HANDSHAKE.SHA256DL
	);
	const digest = calcHmac(msg, GenuineFMSConst);
	digest.copy(handshakeBytes, serverDigestOffset, 0, 32);
	return handshakeBytes;
};

const generateS2 = (messageFormat, clientsig): Buffer => {
	const randomBytes = crypto.randomBytes(HANDSHAKE.RTMP_SIG_SIZE - 32);
	let challengeKeyOffset: number;
	if (messageFormat === 1) {
		challengeKeyOffset = getClientGenuineFPConstDigestOffset(clientsig.slice(8, 12));
	} else {
		challengeKeyOffset = getServerGenuineFMSConstDigestOffset(clientsig.slice(772, 776));
	}

	const challengeKey = clientsig.slice(challengeKeyOffset, challengeKeyOffset + 32);
	const digest = calcHmac(challengeKey, GenuineFMSConstCrud);
	const signature = calcHmac(randomBytes, digest);
	const s2Bytes = Buffer.concat([randomBytes, signature], HANDSHAKE.RTMP_SIG_SIZE);

	return s2Bytes;
};

export const generateS0S1S2 = (clientsig: Uint8Array): Buffer => {
	const clientType = Buffer.alloc(1, 3);
	const messageFormat = detectMessageFormat(clientsig);
	let buffer: Buffer;
	if (messageFormat === HANDSHAKE.MESSAGE_FORMAT._0)
		buffer = Buffer.concat([clientType, clientsig, clientsig]);
	else {
		buffer = Buffer.concat([
			clientType,
			generateS1(messageFormat),
			generateS2(messageFormat, clientsig)
		]);
	}
	return buffer;
};
